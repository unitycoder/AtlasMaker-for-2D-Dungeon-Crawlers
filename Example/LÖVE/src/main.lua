--[[
	
	Simple example of how to use an atlas generated by the AtlasMaker

	https://github.com/zooperdan/AtlasMaker-for-2D-Dungeon-Crawlers

	- zooperdan

]]--

json = require "libs/json"

local screen = {width = 320, height = 256}
local canvas
local atlasImage
local atlasData

local party =  {
	direction = 1,
	x = 2,
	y = 2
}

local map = {
	width = 8,
	height = 8,
	squares = {
		{1,1,1,1,1,1,1,1},
		{1,0,0,0,1,0,0,1},
		{1,0,0,1,1,1,0,1},
		{1,0,0,0,0,1,0,1},
		{1,1,1,1,0,0,0,1},
		{1,0,0,0,0,1,1,1},
		{1,0,0,1,0,0,0,1},
		{1,1,1,1,1,1,1,1}
	},
	objects = {
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,1,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0},
		{0,1,0,0,0,0,0,0},
		{0,0,0,0,0,0,1,0},
		{0,0,0,0,0,0,0,0}
	}	

}

function love.load(arg)

	love.graphics.setDefaultFilter( "nearest", "nearest", 0)

	canvas = love.graphics.newCanvas(screen.width, screen.height)
	
	atlasImage = love.graphics.newImage("files/atlas.png")
	atlasData = loadJSON("files/atlas.json")
	
end

function love.update(dt)

	renderDungeon()
	
end

function love.keypressed(key)

	local key = string.lower(key)

	if key == 'up' or key == 'kp8' or key == 'w' then
		moveForward()
		return
	end
	
	if key == 'down' or key == 'kp5' or key == 's' then
		moveBackward()
		return
	end
	
	if key == 'left' or key == 'kp7' or key == 'q' then
		party.direction = party.direction - 1
		if party.direction < 0 then
			party.direction = 3
		end
		return
	end

	if key == 'right' or key == 'kp9' or key == 'e' then
		party.direction = party.direction + 1
		if party.direction > 3 then
			party.direction = 0
		end
		return
	end	

	if key == 'escape' then
		love.event.quit()
	end
	
end

function love.draw(dt)
	
	love.graphics.push()
	love.graphics.scale(love.graphics.getWidth() / screen.width)
	love.graphics.draw(canvas)
	love.graphics.pop()
	
end

function moveForward()

	local x,y = party.x,party.y

	if party.direction == 0 then
		y = party.y - 1
	elseif party.direction == 1 then
		x = party.x + 1
	elseif party.direction == 2 then
		y = party.y + 1
	elseif party.direction == 3 then
		x = party.x - 1
	end	

	if map.squares[x][y] == 1 then
		return
	end
	
	party.x = x
	party.y = y
	
end

function moveBackward()

	local x,y = party.x,party.y

	if party.direction == 0 then
		y = party.y + 1
	elseif party.direction == 1 then
		x = party.x - 1
	elseif party.direction == 2 then
		y = party.y - 1
	elseif party.direction == 3 then
		x = party.x + 1
	end	

	if map.squares[x][y] == 1 then
		return
	end

	party.x = x
	party.y = y
	
end

function renderDungeon()

	love.graphics.setCanvas(canvas)
	love.graphics.clear()
	love.graphics.setColor(1,1,1,1)

	drawBackground("ground")
	drawBackground("ceiling")
	
    for z = -atlasData.depth, 0 do
		
		for x = -atlasData.width, -1 do
			drawSquare(x, z)
		end		

		for x = atlasData.width, 1, -1 do
			drawSquare(x, z)
		end		
		
		drawSquare(0, z)
	
	end

	love.graphics.setCanvas()

end

function getPlayerDirectionVectorOffsets(x, z)

    if party.direction == 0 then
        return { x = party.x + x, y = party.y + z };
	elseif party.direction == 1 then
		return { x = party.x - z, y = party.y + x };
	elseif party.direction == 2 then
		return { x = party.x - x, y = party.y - z };
	elseif party.direction == 3 then
		return { x = party.x + z, y = party.y - x };
	end
	
end

function drawSquare(x, z)

    local p = getPlayerDirectionVectorOffsets(x, z);

    if p.x >= 1 and p.y >= 1 and p.x <= map.width and p.y <= map.height then

		if map.squares[p.x][p.y] == 1 then
			drawSideWalls("wall", x, z)
		end
		
		if map.squares[p.x][p.y] == 1 then
			drawFrontWalls("wall", x, z)
		end
	
		if map.objects[p.x][p.y] ~= 0 then
			drawObject("object", x, z)
		end
	
	end

end

function drawObject(layerId, x, z)

	local bothsides = atlasData.layers[layerId] and atlasData.layers[layerId].mode == 2
	local xx = bothsides and x - (x * 2) or 0
	local tile = getTile(layerId, "object", xx, z);

	if tile then

		local quad = love.graphics.newQuad(tile.coords.x, tile.coords.y, tile.coords.w, tile.coords.h, atlasImage:getWidth(), atlasImage:getHeight())

		if bothsides then
			love.graphics.draw(atlasImage, quad, tile.screen.x, tile.screen.y)
		else
			local tx = tile.screen.x + (x * tile.coords.w)
			love.graphics.draw(atlasImage, quad, tx, tile.screen.y)
		end

	end
	
end

function drawBackground(layerId)
	
	local bothsides = atlasData.layers[layerId] and atlasData.layers[layerId].mode == 2

    for z = -atlasData.depth, 0 do
		
		for x = -atlasData.width, atlasData.width do

			local xx = bothsides and x - (x * 2) or 0
			local tile = getTile(layerId, layerId, xx, z);
			
			if tile then

				local quad = love.graphics.newQuad(tile.coords.x, tile.coords.y, tile.coords.w, tile.coords.h, atlasImage:getWidth(), atlasImage:getHeight())

				if bothsides then
					love.graphics.draw(atlasImage, quad, tile.screen.x, tile.screen.y)
				else
					local tx = tile.screen.x + (x * tile.coords.w)
					love.graphics.draw(atlasImage, quad, tx, tile.screen.y)
				end

			end			
			
		end		

	end
	
end

function drawFrontWalls(layerId, x, z)

	local bothsides = atlasData.layers[layerId] and atlasData.layers[layerId].mode == 2
	local xx = bothsides and x - (x * 2) or 0
	local tile = getTile(layerId, "front", xx, z);

	if tile then

		local quad = love.graphics.newQuad(tile.coords.x, tile.coords.y, tile.coords.w, tile.coords.h, atlasImage:getWidth(), atlasImage:getHeight())

		if bothsides then
			love.graphics.draw(atlasImage, quad, tile.screen.x, tile.screen.y)
		else
			--print(inspect(tile))
			local tx = tile.screen.x + (x * tile.coords.w)
			love.graphics.draw(atlasImage, quad, tx, tile.screen.y)
		end

	end
	
end

function drawSideWalls(layerId, x, z)

	if x <= 0 then

		local tile = getTile(layerId, "side", x - (x * 2), z);

		if tile then
			local quad = love.graphics.newQuad(tile.coords.x, tile.coords.y, tile.coords.w, tile.coords.h, atlasImage:getWidth(), atlasImage:getHeight())
			love.graphics.draw(atlasImage, quad, tile.screen.x, tile.screen.y)
		end

	end

	if x >= 0 then
	
		local tile = getTile(layerId, "side", x, z);

		if tile then
			local quad = love.graphics.newQuad(tile.coords.x, tile.coords.y, tile.coords.w, tile.coords.h, atlasImage:getWidth(), atlasImage:getHeight())
			local tx = screen.width - tile.screen.x
			love.graphics.draw(atlasImage, quad, tx, tile.screen.y, 0, -1, 1)
		end

	end	
	
end

function getTile(layerId, tileType, x, z)

	if not atlasData.layers[layerId] then
		return nil
	end

	local layer = atlasData.layers[layerId]
	
	if not layer then return false end
	
	for i = 1, #layer.tiles do
		local tile = layer.tiles[i]
		if tile.type == tileType and tile.tile.x == x and tile.tile.y == z then
			return tile
		end
	end

	return nil
	
end

function loadJSON(filename)

	local result = {}

	contents, size = love.filesystem.read("string", filename)
	
	if contents and size then
		
		local data = json.parse(contents)

		result = {
			version = data.version,
			generated = data.generated,
			resolution = data.resolution,
			depth = data.depth,
			width = data.width,
			layers = {}
		}
		
		for i = 1, #data.layers do
			result.layers[data.layers[i].name] = data.layers[i]
		end
		
	end	
	
	return result
		
end